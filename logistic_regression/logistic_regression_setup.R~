library(mvtnorm)

# Declare constants of the data (i.e. seed values, dimension values, dataset sizes)
getSimConsts = function() {
    consts = list()
    consts$N = 10^5
    consts$Ntest = 10^2
    consts$ds = c(10, 50, 100)
    consts$seeds = 1:5
    consts$hs = c(4e-6, 1e-6, 7e-7, 4e-7, 1e-7, 7e-8)
    consts$hsOpt = c(4e-6, 1e-6, 7e-7, 4e-7, 1e-7, 7e-8)
    consts$minibatchSize = .01
    consts$nItersOpt = 10^3
    return(consts)
}

# Create required dataset for current simulation
lregDim = function(d, seed) {
    simConsts = getSimConsts()
    # Vary scales to simulate beta from so parameter contribution varies
    beta_scales = c(.1, 1, 10)
    set.seed(seed)
    # Generate covariance matrix for covariates Sigma0.
    # Of the form diag(Sigma0) = 1 and Sigma0[i,j] ~ Unif(-rho, rho)^(i-j)
    # The aim is to emulate standardised covariates with a small amount of correlation
    rho = .4
    Sigma0 = genCovMat(d, rho)
    # Simulate covariates, parameters and predictors
    X = rmvnorm(simConsts$N, rep(0, d), Sigma0)
    beta = rnorm(d, 0, sample(beta_scales, d, replace = T))
    probs = apply(X, 1, function (x_i) 1 / (1 + exp(-sum(x_i * beta))))
    y = rbinom(length(probs), 1, probs)
    params = list("beta"=beta)
    data = list("X" = X, "y" = y)
    # Simulate covariates, parameters and predictors for test set
    X = rmvnorm(simConsts$Ntest, rep(0, d), Sigma0)
    probs = apply(X, 1, function (x_i) 1 / (1 + exp(-sum(x_i * beta))))
    y = rbinom(length(probs), 1, probs)
    test = list("X" = X, "y" = y)
    # Store additional constants
    out = list("data" = data, "test" = test, "params"= params)
}

# Generate a Symmetric, correlated matrix Sigma0 with 1s on diagonal
genCovMat = function(d, rho) {
    # Generate matrix with all 1 entries
    Sigma0 = matrix(rep(1, d^2), ncol = d)
    # Simulate lower triangular part from U(-rho, rho)^(distance from i)
    for (i in 2:d) {
        for (j in 1:(i-1)) {
            Sigma0[i,j] = runif(1, -rho, rho)^(i-j)
        }
    }
    # Make matrix symmetric
    Sigma0 = Sigma0 * t(Sigma0)
    return(Sigma0)
}
